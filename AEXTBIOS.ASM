EVEN

; +------------------------------------------------------+
; |   ASSISTENT EXTERNAL-ROM PROCEDURES                  |
; +------------------------------------------------------+
; 	decompilation:  Ruslan Staritsyn, 2022    
;
; F400:0000 = F000:4000 - 1024b GOST font
; F440:0000 = F000:4400 - floppy ext proc
; F460:0000 = F000:4600 - ext cass proc: enabled at K30_ in main bios
; F400:0900 = F000:4900 - assistent logo proc
; F400:1300 = F000:5300 - ext disk-seek proc
; F600:0000 = F000:6000 - BASIC C1.10 32kb
; FE00:0000 = F000:E000 - main bios

; FILL FIRST 8KB ROM AREA
	ORG 4000H
	DB 01000H DUP (255)
	DB 00400H DUP (0)
	DB 00C00H DUP (255)
	
	ORG 4000H	
INCLUDE GOSTCRT.ASM

	ASSUME	CS:CODE,SS:CODE,ES:ABS0,DS:DATA

	; FLOPPY PROC
	ORG 4400H

		STI
		PUSH  BX
		PUSH  CX
		PUSH  DS
		PUSH  SI
		PUSH  DI
		PUSH  BP
		PUSH  DX
		MOV   BP, SP
		MOV   SI, 0040h			; DATA SEGMENT
		MOV   DS, SI
		CLD
		CALL  L_042A
		MOV   BYTE PTR [MOTOR_COUNT], 01	; MOTOR_COUNT
		MOV   AH, BYTE PTR [DISKETTE_STATUS]	; DISKETTE_STATUS
		CMP   AH, 01
		CMC
		POP   DX
		POP   BP
		POP   DI
		POP   SI
		POP   DS
		POP   CX
		POP   BX
		RETF  0002
		
L_042A:
		AND   BYTE PTR [MOTOR_STATUS], 7Fh	; MOTOR_STATUS
		OR    AH, AH
		JZ    L_045A
		DEC   AH
		JZ    L_0465
		MOV   BYTE PTR [DISKETTE_STATUS], 00	; DISKETTE_STATUS
		CMP   DL, 04
		JNC   L_0454
		DEC   AH
		JZ    L_0469
		DEC   AH
		JNZ   L_044C
		JMP   L_04A0
		;NOP
L_044C:
		DEC   AH
		JZ    L_0493
		DEC   AH
		JZ    L_0495
L_0454:
		MOV   BYTE PTR [DISKETTE_STATUS], 01	; DISKETTE_STATUS
		RETN
L_045A:
		MOV   BYTE PTR [SEEK_STATUS], 00	; SEEK_STATUS
		MOV   BYTE PTR [DISKETTE_STATUS], 00	; DISKETTE_STATUS
		RETN
L_0465:
		MOV   AL, [DISKETTE_STATUS]			; DISKETTE_STATUS
		RETN
L_0469:
		PUSH  DS
		PUSH  AX
		CALL  L_04EC
		MOV   SI, WORD PTR DS:[84H]	;
		MOV   DS, AX
		POP   AX
		MOV   DI, BX
		MOV   CL, 05
		SHL   AX, CL
		CALL  L_0514
		JNC   L_0487
L_0480:
		POP   DS
		MOV   BYTE PTR [DISKETTE_STATUS], 80H	; DISKETTE_STATUS
		RETN
L_0487:
		MOV   CL, 04
		SHL   AX, CL
		MOV   CX, AX
		SUB   SI, SI
		REP MOVSB
		POP   DS
		RETN
L_0493:
		JMP  L_045A
L_0495:
		OR    BYTE PTR [MOTOR_STATUS], 80H	; MOTOR_STATUS
		MOV   BYTE PTR [DISKETTE_STATUS], 80H	; DISKETTE_STATUS
		RETN
L_04A0:
		OR    BYTE PTR [MOTOR_STATUS], 80H	; MOTOR_STATUS
		PUSH  DS
		PUSH  AX
		CALL  L_04EC
		MOV   DI, WORD PTR DS:[84H]	; 
		MOV   SI, ES
		MOV   ES, AX
		MOV   DS, SI
		MOV   SI, BX
		POP   AX
		MOV   CL, 05
		SHL   AX, CL
		CALL  L_051F
		JNC   L_04C2
		JMP   L_0480
L_04C2:
		MOV   CL, 04
		SHL   AX, CL
		MOV   CX, AX
		SUB   DI, DI
		REP MOVSB
		POP   DS
		RETN
		
		PUSH  DS
		SUB   AX, AX
		MOV   DS, AX
		LDS   SI, DS:[78H]			; INT 1E VECTOR
		SHR   BX, 1
		MOV   AH, BYTE PTR [BX+SI]
		POP   DS
		RETN
L_04DD:
		RETN

L_04DE:
		PUSH  DS
		XOR   SI, SI
		MOV   DS, SI
		LDS   SI, DS:[78H]			; INT 1E VECTOR
		MOV   CL, BYTE PTR [SI+04]
		POP   DS
		RETN

L_04EC:
		PUSH  CX
		SHL   CH, 1
		ADD   CH, DH
		CALL  L_04DE
		SUB   AX, AX
		MOV   AL, CH
		MUL   CL
		POP   CX
		PUSH  CX
		DEC   CL
		MOV   CH, 00
		ADD   AX, CX
		PUSH  BX
		MOV   BX, WORD PTR DS:[13H]
		MOV   CL, 06
		SHL   BX, CL
		MOV   CL, 05
		SHL   AX, CL
		ADD   AX, BX
		POP   BX
		POP   CX
		RETN

L_0514:
		MOV   BX, DS
		ADD   BX, AX
		MOV   CL, 06
		SHL   SI, CL
		CMP   SI, BX
		RETN

L_051F:
		MOV   BX, ES
		ADD   BX, AX
		MOV   CL, 06
		SHL   DI, CL
		CMP   DI, BX
		RETN


; EXTERNAL FLOPPY-SEEK PROCEDURE

	ORG 5300H

EXT_SEEK	PROC	NEAR
	 MOV   AL, 01
	 PUSH  CX
	 MOV   CL, DL
	 ROL   AL, CL
	 POP   CX
	 TEST  BYTE PTR SEEK_STATUS, AL
	 JNZ   A5321
	 OR    BYTE PTR SEEK_STATUS, AL
	 MOV   AH, 07
	 CALL  NEC_OUTPUT		;  NEC_OUTPUT	EE83
	 MOV   AH, DL
	 CALL  NEC_OUTPUT		;  NEC_OUTPUT
	 CALL  CHK_STAT_2		;  CHK_STAT_2	EEE6
	 JC    A5354
A5321: 
	MOV   AH, 0FH
	 CALL  NEC_OUTPUT
	 MOV   AH, DL
	 CALL  NEC_OUTPUT
	 MOV   AH, CH
	 TEST  BYTE PTR EQUIP_FLAG+1, 20h
	 JNZ   A5336
	 SHL   AH, 1
A5336:
	 CALL  NEC_OUTPUT
	 CALL  CHK_STAT_2
	 PUSHF
	 MOV   BX, 0012H
	 CALL  GET_PARM		; GET_PARM	EEAF
	 PUSH  CX
A5344:
	 MOV   CX, 0226H
	 OR    AH, AH
	 JZ    A5351
A534B:
	 LOOP  A534B
	 DEC   AH
	 JMP  A5344
A5351:
	 POP   CX
	 POPF
A5353:
	 RET
A5354:
	 MOV   AH, 07
	 CALL  NEC_OUTPUT
	 MOV   AH, DL
	 CALL  NEC_OUTPUT
	 CALL  CHK_STAT_2
	 JC    A5353
	 JMP   A5321
EXT_SEEK ENDP



;--- ORIGINAL IBM PC CASSETTE I/O ----------

;	THIS VECTOR SET UP WITH CTRL+ALT+1 
	ORG 4600H
	
;--- INT 15 --------------------------------
; CASSETTE I/O
;	(AH) = 0  TURN CASSETTE MOTOR ON
;	(AH) = 1  TURN CASSETTE MOTOR OFF
;	(AH) = 2  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
;		(ES,BX) = POINTER TO DATA BUFFER
;		(CX) = COUNT OF BYTES TO READ
;		ON EXIT:
;		(ES,BX) = POINTER TO LAST BYTE READ + 1
;		(DX) = COUNT OF BYTES ACTUALLY READ
;		(CY) = 0 IF NO ERROR OCCURRED
;		     = 1 IF ERROR OCCURRED
;		(AH) = ERROR RETURN IF (CY)= 1
;			= 01 IF CRC ERROR WAS DETECTED
;			= 02 IF DATA TRANSITIONS ARE LOST
;			= 04 IF NO DATA WAS FOUND
;	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
;		(ES,BX) = POINTER TO DATA BUFFER
;		(CX) = COUNT OF BYTES TO WRITE
;		ON EXIT:
;		(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1
;		(CX) = 0
;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1
;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).
;--------------------------------------------
	ASSUME	DS:DATA,ES:NOTHING,SS:NOTHING,CS:CODE
CASSETTE_IO2	PROC	FAR
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; ESTABLISH ADDRESSING TO DATA
	PUSH	AX
	MOV	AX,DATA
	MOV	DS,AX
	AND	BIOS_BREAK, 7FH 	; MAKE SURE BREAK FLAG IS OFF
	POP	AX
	CALL	W1_			; CASSETTE_IO_CONT
	POP	DS
	RET	2		; INTERRUPT RETURN
CASSETTE_IO2	ENDP
W1_	PROC	NEAR
;--------------------------------------------
; PURPOSE:
;  TO CALL APPROPRIATE ROUTINE DEPENDING ON REG AH
;
;  AH		ROUTINE
;--------------------------------------------
;  0		MOTOR ON
;  1		MOTOR OFF
;  2		READ CASSETTE BLOCK
;  3		WRITE CASSETTE BLOCK
;--------------------------------------------

	OR	AH,AH		;TURN ON MOTOR?
	JZ	MOTOR_ON_	;YES, DO IT
	DEC	AH		;TURN OFF MOTOR?
	JZ	MOTOR_OFF_	;YES, DO IT
	DEC	AH		;READ CASSETTE BLOCK?
	JZ	READ_BLOCK_	;YES, DO IT
	DEC	AH		;WRITE CASSETTE BLOCK?
	JNZ	W2_		; NOT_DEFINED
	JMP	WRITE_BLOCK_	;YES, DO IT

W2_:				;COMMAND NOT DEFINED
	MOV	AH,080H 	;ERROR, UNDEFINED OPERATION
	STC			;ERROR FLAG
	RET
W1_	ENDP

MOTOR_ON_	PROC	NEAR
;--------------------------------
; PURPOSE:
;  TO TURN ON CASSETTE MOTOR
;---------------------------------
	IN	AL,PORT_B		;READ CASSETTE OUTPUT
	AND	AL,NOT 08H		; CLEAR BIT TO TURN ON MOTOR
W3_:	OUT	PORT_B,AL		;WRITE IT OUT
	SUB	AH,AH			;CLEAR AH
	RET
MOTOR_ON_	ENDP

MOTOR_OFF_	PROC	NEAR
;----------------------------------
; PURPOSE:
; TO TURN CASSETTE MOTOR OFF
;-----------------------------------
	IN	AL,PORT_B		;READ CASSETTE OUTPUT
	OR	AL,08H			; SET BIT TO TURN OFF
	JMP	W3_			;WRITE IT, CLEAR ERROR, RETURN
MOTOR_OFF_	ENDP
READ_BLOCK_	PROC	NEAR
;--------------------------------------------
; PURPOSE:
;  TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
;
; ON ENTRY:
;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
;  BX POINTS TO START OF MEMORY BUFFER
;  CX CONTAINS NUMBER OF BYTES TO READ
; ON EXIT:
;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
;  CX CONTAINS DECREMENTED BYTE COUNT
;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
;
;  CARRY FLAG IS CLEAR IF NO ERROR DETECTED
;  CARRY FLAG IS SET IF CRC ERROR DETECTED
;--------------------------------------------
	PUSH	BX			;SAVE BX
	PUSH	CX			;SAVE CX
	PUSH	SI			; SAVE SI
	MOV	SI, 7			; SET UP RETRY COUNT FOR LEADER
	CALL	BEGIN_OP_		; BEGIN BY STARTING MOTOR
W4_:					; SEARCH FOR LEADER
	IN	AL,PORT_C		;GET INTIAL VALUE
	AND	AL,010H 		;MASK OFF EXTRANEOUS BITS
	MOV	LAST_VAL,AL		;SAVE IN LOC LAST_VAL
	MOV	DX,16250		; # OF TRANSITIONS TO LOOK FOR

W5_:					; WAIT_FOR_EDGE
	TEST	BIOS_BREAK,80H		; CHECK FOR BREAK KEY
	JZ	W6_			; JUMP IF NO BREAK KEY
	JMP	W17_			; JUMP IF BREAK KEY HIT

W6_:	DEC	DX
	JNZ	W7_			; JUMP IF BEGINNING OF LEADER
	JMP	W17_			; JUMP IF NO LEADER FOUND

W7_:	CALL	READ_HALF_BIT_		;IGNORE FIRST EDGE
	JCXZ	W5_			; JUMP IF NO EDGE DETECTED
	MOV	DX,0378H		; CHECK FOR HALF BITS
	MOV	CX,200H 		;MUST HAVE AT LEAST THIS MANY ONE SIZE
					;PULSES BEFORE CHECKNG FOR SYNC BIT (0)
	IN	AL, 021H		; INTERRUPT MASK REGISTER
	OR	AL, 1			; DISABLE TIMER INTERRUPTS
	OUT	021H, AL
W8_:					; SEARCH_LDR
	TEST	BIOS_BREAK, 80H 	; CHECK FOR BREAK KEY
	JNZ	W17_			; JUMP IF BREAK KEY HIT
	PUSH	CX			;SAVE REG CX
	CALL	READ_HALF_BIT_		;GET PULSE WIDTH
	OR	CX,CX			; CHECK FOR TRANSITION
	POP	CX			;RESTORE ONE BIT COUNTER
	JZ	W4_			; JUMP IF NO TRANSITION
	CMP	DX,BX			;CHECK PULSE WIDTH
	JCXZ	W9_			;IF CX=0 THEN WE CAN LOOK
					;FOR SYNC BIT (0)
	JNC	W4_			; JUMP IF ZERO BIT (NOT GOOD LEADER)
	LOOP	W8_			;DEC CX AND READ ANOTHER HALF ONE BIT
W9_:					; FIND_SYNC
	JC	W8_			; JUMP IF ONE BIT (STILL LEADER)

; A SYNCH BIT HAS BEEN FOUND. READ SYN CHARACTER:

	CALL	READ_HALF_BIT_		;SKIP OTHER HALF OF SYNC BIT (0)
	CALL	READ_BYTE_		; READ SYN BYTE
	CMP	AL, 16H 		; SYNCHRONIZATION CHARACTER
	JNE	W16_			; JUMP IF BAD LEADER FOUND.

;------ GOOD CRC SO READ DATA BLOCK(S)
	POP	SI			; RESTORE REGS
	POP	CX
	POP	BX
;--------------------------------------------
;  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
;
; ON ENTRY:
;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
;  BX POINTS TO START OF MEMORY BUFFER
;  CX CONTAINS NUMBER OF BYTES TO READ
; ON EXIT:
;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
;  CX CONTAINS DECREMENTED BYTE COUNT
;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
;--------------------------------------------
	PUSH	CX			;SAVE BYTE COUNT
W10_:					;COME HERE BEFORE EACH
					;256 BYTE BLOCK IS READ
	MOV	CRC_REG,0FFFFH		;INIT CRC REG
	MOV	DX,256			;SET CX TO DATA BLOCK SIZE
W11_:					; RD_BLK
	TEST	BIOS_BREAK, 80H 	; CHECK FOR BREAK KEY
	JNZ	W13_			; JUMP IF BREAK KEY HIT
	CALL	READ_BYTE_		;READ BYTE FROM CASSETTE
	JC	W13_			;CY SET INDICATES NO DATA TRANSITIONS
	JCXZ	W12_			;IF WE'VE ALREADY REACHED
					;END OF MEMORY BUFFER
					;SKIP REST OF BLOCK
	MOV	ES:[BX],AL		;STORE DATA BYTE AT BYTE PTR
	INC	BX			;INC BUFFER PTR
	DEC	CX			;DEC BYTE COUNTER
W12_:			; LOOP UNTIL DATA BLOCK HAS BEEN READ FROM CASSETTE.
	DEC	DX			;DEC BLOCK CNT
	JG	W11_			; RD_BLK
	CALL	READ_BYTE_		;NOW READ TWO CRC BYTES
	CALL	READ_BYTE_
	SUB	AH,AH			;CLEAR AN
	CMP	CRC_REG,1D0FH		;IS THE CRC CORRECT
	JNE	W14_			;IF NOT EQUAL CRC IS BAD
	JCXZ	W15_			;IF BYTE COUNT IS ZERO
					;THEN WE HAVE READ ENOUGH
					;SO WE WILL EXIT
	JMP	W10_			;STILL MORE, SO READ ANOTHER BLOCK
W13_:					;MISSING_DATA
					;NO DATA TRANSITIONS SO
	MOV	AH,01H			;SET AH=02 TO INDICATE
					;DATA TIMEOUT
W14_:					; BAD_CRC
	INC	AH			;EXIT EARLY ON ERROR
					;SET AH=01 TO INDICATE CRC ERROR
W15_:					; RD_BLK_EX
	POP	DX			;CALCULATE COUNT OF
	SUB	DX,CX			;DATA BYTES ACTUALLY READ
					;RETURN COUNT IN REG DX
	PUSH	AX			;SAVE AX (RET CODE)
	TEST	AH, 03H 		; CHECK FOR ERRORS
	JNZ	W18_			; JUMP IF ERROR DETECTED
	CALL	READ_BYTE_		;READ TRAILER
	JMP	SHORT W18_		;SKIP TO TURN OFF MOTOR
W16_:					; BAD_LEADER
	DEC	SI			; CHECK RETRIES
	JZ	W17_			; JUMP IF TOO MANY RETRIES
	JMP	W4_			; JUMP IF NOT TOO MANY RETRIES
W17_:					;NO VALID DATA FOUND
;------ NO DATA FROM CASSETTE ERROR, I.E. TIMEOUT

	POP	SI			; RESTORE REGS
	POP	CX			;RESTORE REGS
	POP	BX
	SUB	DX,DX			;ZERO NUMBER OF BYTES READ
	MOV	AH,04H			;TIME OUT ERROR (NO LEADER)
	PUSH	AX
W18_:					; MOT-OFF
	IN	AL, 021H		; RE_ENABLE INTERRUPTS
	AND	AL, 0FFH-1
	OUT	021H, AL
	CALL	MOTOR_OFF_		;TURN OFF MOTOR
	POP	AX			;RESTORE RETURN CODE
	CMP	AH,01H			;SET CARRY IF ERROR (AH>0)
	CMC
	RET				;FINISHED
READ_BLOCK_	ENDP
;------------------------------------------
READ_BYTE_	PROC	NEAR
; PURPOSE:
;  TO READ A BYTE FROM CASSETTE
;
; ON EXIT REG AL CONTAINS READ DATA BYTE
;-------------------------------------------
	PUSH	BX			;SAVE REGS BX,CX
	PUSH	CX
	MOV	CL,8H			; SET BIT COUNTER FOR 8 BITS
W19_:					; BYTE_ASM
	PUSH	CX			; SAVE CX
;-------------------------------------------
;  READ DATA BIT FROM CASSETTE
;-------------------------------------------
	CALL	READ_HALF_BIT_		;READ ONE PULSE
	JCXZ	W21_			;IF CX=0 THEN TIMEOUT
					;BECAUSE OF NO DATA TRANSITIONS
	PUSH	BX			;SAVE 1ST HALF BIT'S
					;PULSE WIDTH (IN BX)
	CALL	READ_HALF_BIT_		;READ COMPLEMENTARY PULSE
	POP	AX			;COMPUTE DATA BIT
	JCXZ	W21_			;IF CX=0 THEN TIMEOUT DUE TO
					;NO DATA TRANSITIONS
	ADD	BX,AX			;PERIOD
	CMP	BX, 06F0H		; CHECK FOR ZERO BIT
	CMC				; CARRY IS SET IF ONE BIT
	LAHF				;SAVE CARRY IN AH
	POP	CX			;RESTORE CX
					;NOTE:
					; MS BIT OF BYTE IS READ FIRST.
					; REG CH IS SHIFTED LEFT WITH
					; CARRY BEING INSERTED INTO LS
					;   BIT OF CH.
					; AFTER ALL 8 BITS HAVE BEEN
					;   READ, THE MS BIT OF THE DATA BYTE
					;   WILL BE IN THE MS BIT OF REG CH
	RCL	CH,1			;ROTATE REG CH LEFT WITH CARRY TO
					;   LS BIT OF REG CH
	SAHF				;RESTORE CARRY FOR CRC ROUTINE
	CALL	CRC_GEN_ 		;GENERATE CRC FOR BIT
	DEC	CL			;LOOP TILL ALL 8 BITS OF DATA
					;ASSEMBLED IN REG CH
	JNZ	W19_			; BYTE_ASM
	MOV	AL,CH			;RETURN DATA BYTE IN REG AL
	CLC
W20_:					; RD_BYT_EX
	POP	CX			;RESTORE REGS CX,BX
	POP	BX
	RET				;FINISHED
W21_:					; NO_DATA
	POP	CX			;RESTORE CX
	STC				;INDICATE ERROR
	JMP	W20_			; RD_BYT_EX
READ_BYTE_	ENDP
;--------------------------------------------
READ_HALF_BIT_	PROC	NEAR
; PURPOSE
;  TO COMPUTE TIME TILL NEXT DATA
;  TRANSITION (EDGE)
;
; ON ENTRY:
;  EDGE_CNT CONTAINS LAST EDGE COUNT
;
; ON EXIT:
;  AX CONTAINS OLD LAST EDGE COUNT
;  BX CONTAINS PULSE WIDTH (HALF BIT)
;----------------------------------------
	MOV	CX, 100 		; SET TIME TO WAIT FOR BIT
	MOV	AH,LAST_VAL		;GET PRESENT INPUT VALUE
W22_:					; RD-H-BIT
	IN	AL,PORT_C		;INPUT DATA BIT
	AND	AL,010H 		;MASK OFF EXTRANEOUS BITS
	CMP	AL,AH			;SAME AS BEFORE?
	LOOPE	W22_			;LOOP TILL IT CHANGES
	MOV	LAST_VAL,AL		;UPDATE LAST_VAL WITH NEW VALUE
	MOV	AL,0			;READ TIMER'S COUNTER COMMAND
	OUT	TIM_CTL,AL		;LATCH COUNTER
	;MOV	BX,EDGE_CNT		;BX GETS LAST EDGE COUNT
	IN	AL,TIMER0		;GET LS BYTE
	MOV	AH,AL			;SAVE IN AH
	IN	AL,TIMER0		;GET MS BYTE
	XCHG	AL,AH			;XCHG AL,AH
	MOV	BX,EDGE_CNT		;BX GETS LAST EDGE COUNT
	SUB	BX,AX			;SET BX EQUAL TO HALF BIT PERIOD
	MOV	EDGE_CNT,AX		;UPDATE EDGE COUNT;
	RET
READ_HALF_BIT_	ENDP
;-----------------------------------------
WRITE_BLOCK_	PROC	NEAR
;
; WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE.
;	THE DATA IS PADDED TO FILL OUT THE LAST 256 BYTE BLOCK.
;
;  ON ENTRY:
;   BX POINTS TO MEMORY BUFFER ADDRESS
;   CX CONTAINS NUMBER OF BYTES TO WRITE
;
;  ON EXIT:
;   BX POINTS 1 BYTE PAST LAST BYTE WRITTEN TO CASSETTE
;   CX IS ZERO
;--------------------------------------------
	PUSH	BX
	PUSH	CX
	IN	AL,PORT_B		;DISABLE SPEAKER
	AND	AL,NOT 02H
	OR	AL, 01H 		; ENABLE TIMER
	OUT	PORT_B,AL
	MOV	AL,0B6H 		; SET UP TIMER -- MODE 3 SQUARE WAVE
	OUT	TIM_CTL,AL
	CALL	BEGIN_OP_		; START MOTOR AND DELAY
	MOV	AX,1184 		; SET NORMAL BIT SIZE
	CALL	W31_			; SET_TIMER
	MOV	CX,0800H		;SET CX FOR LEADER BYTE COUNT
W23_:					; WRITE LEADER
	STC				; WRITE ONE BITS
	CALL	WRITE_BIT_		;
	LOOP	W23_			; LOOP 'TIL LEADER IS WRITTEN
	CLC				;WRITE SYNC BIT (0)
	CALL	WRITE_BIT_
	POP	CX			;RESTORE REGS CX,BX
	POP	BX
	MOV	AL, 16H 		; WRITE SYN CHARACTER
	CALL	WRITE_BYTE_		;
;-------------------------------------------
;  WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
;
;  ON ENTRY:
;   BX POINTS TO MEMORY BUFFER ADDRESS
;   CX CONTAINS NUMBER OF BYTES TO WRITE
;
;  ON EXIT:
;   BX POINTS 1 BYTE PAST LAST BYTE WRITTEN TO CASSETTE
;   CX IS ZERO
;------------------------------------------
WR_BLOCK_:
	MOV	CRC_REG,0FFFFH		;INIT CRC
	MOV	DX,256			;FOR 256 BYTES
W24_:					; WR_BLK
	MOV	AL,ES:[BX]		;READ BYTE FROM MEM
	CALL	WRITE_BYTE_		;WRITE IT TO CASSETTE
	JCXZ	W25_			;UNLESS CX=0, ADVANCE PTRS & DEC COUNT
	INC	BX			;INC BUFFER POINTER
	DEC	CX			;DEC BYTE COUNTER
W25_:					; SKIP_ADV
	DEC	DX			;DEC BLOCK CNT
	JG	W24_			;LOOP TILL 256 BYTE BLOCK
					; IS WRITTEN TO TAPE
;------------------- WRITE CRC --------------
;  WRITE 1'S COMPLEMENT OF CRC REG TO CASSETTE
;  WHICH IS CHECKED FOR CORRECTNESS WHEN THE BLOCK IS READ
;
;  REG AX IS MODIFIED
;------------------------------------------
	MOV	AX,CRC_REG		;WRITE THE ONE'S COMPLEMENT OF THE
					;  TWO BYTE CRC TO TAPE
	NOT	AX			;FOR 1'S COMPLEMENT
	PUSH	AX			;SAVE IT
	XCHG	AH,AL			;WRITE MS BYTE FIRST
	CALL	WRITE_BYTE_		;WRITE IT
	POP	AX			;GET IT BACK
	CALL	WRITE_BYTE_		;NOW WRITE LS BYTE
	OR	CX,CX			;IS BYTE COUNT EXHAUSTED?
	JNZ	WR_BLOCK_		;JUMP IF NOT DONE YET
	PUSH	CX			;SAVE REG CX
	MOV	CX, 32			;WRITE OUT TRAILER BITS
W26_:					; TRAIL_LOOP
	STC
	CALL	WRITE_BIT_
	LOOP	W26_			; WRITE UNTIL TRAILER WRITTEN
	POP	CX			;RESTORE REG CX
	MOV	AL, 0B0H		; TURN TIMER2 OFF
	OUT	TIM_CTL,AL
	MOV	AX, 1
	CALL	W31_			; SET_TIMER
	CALL	MOTOR_OFF_		;TURN MOTOR OFF
	SUB	AX,AX			;NO ERRORS REPORTED ON WRITE OP
	RET				;FINISHED
WRITE_BLOCK_	ENDP
;------------------------------------------
WRITE_BYTE_	PROC	NEAR
;  WRITE A BYTE TO CASSETTE.
;  BYTE TO WRITE IS IN REG AL.
;--------------------------------------------
	PUSH	CX			;SAVE REGS CX,AX
	PUSH	AX
	MOV	CH,AL			;AL=BYTE TO WRITE.
					;   (MS BIT WRITTEN FIRST)
	MOV	CL,8			;FOR 8 DATA BITS IN BYTE.
					;   NOTE: TWO EDGES PER BIT
W27_:					; DISASSEMBLE THE DATA BIT
	RCL	CH,1			;ROTATE MS BIT INTO CARRY
	PUSHF				;SAVE FLAGS.
					;   NOTE: DATA BIT IS IN CARRY
	CALL	WRITE_BIT_		;WRITE DATA BIT
	POPF				;RESTORE CARRY FOR CRC CALC
	CALL	CRC_GEN_ 		;COMPUTE CRC ON DATA BIT
	DEC	CL			;LOOP TILL ALL 8 BITS DONE
	JNZ	W27_			; JUMP IF NOT DONE YET
	POP	AX			;RESTORE REGS AX,CX
	POP	CX
	RET				;WE ARE FINISHED
WRITE_BYTE_	ENDP
;---------------------------------------
WRITE_BIT_	PROC	NEAR
; PURPOSE:
;
;  TO WRITE A DATA BIT TO CASSETTE
;  CARRY FLAG CONTAINS DATA BIT
;  I.E. IF SET	 DATA BIT IS A ONE
;	IF CLEAR DATA BIT IS A ZERO
;
;  NOTE: TWO EDGES ARE WRITTEN PER BIT
;	 ONE BIT HAS 500 USEC BETWEEN EDGES
;	     FOR A 1000 USEC PERIOD (1 MILLISEC)
;
;	 ZERO BIT HAS 250 USEC BETWEEN EDGES
;	     FOR A  500 USEC PERIOD (.5 MILLISEC)
; CARRY FLAG IS DATA BIT
;-------------------------------------------
					;ASSUME IT'S A '1'
	MOV	AX,1184 		; SET AX TO NOMINAL ONE SIZE
	JC	W28_			; JUMP IF ONE BIT
	MOV	AX,592			; NO, SET TO NOMINAL ZERO SIZE
W28_:					; WRITE_BIT_AX
	PUSH	AX			;WRITE BIT WITH PERIOD EQ TO VALUE AX
W29_:
	IN	AL,PORT_C		;INPUT TIMER_0 OUTPUT
	AND	AL,020H
	JZ	W29_			;LOOP TILL HIGH
W30_:
	IN	AL,PORT_C		;NOW WAIT TILL TIMER'S OUTPUT IS LOW
	AND	AL,020H
	JNZ	W30_
					;RELOAD TIMER WITH PERIOD
					;FOR NEXT DATA BIT
	POP	AX			;RESTORE PERIOD COUNT
W31_:					; SET TIMER
	OUT	042H, AL		; SET LOW BYTE OF TIMER 2
	MOV	AL, AH
	OUT	042H, AL		; SET HIGH BYTE OF TIMER 2
	RET
WRITE_BIT_	ENDP
;-----------------------------------------
CRC_GEN_ 	PROC	NEAR
;  UPDATE CRC REGISTER WITH NEXT DATA BIT
;
;  CRC IS USED TO DETECT READ ERRORS
;
;  ASSUMES DATA BIT IS IN CARRY
;
;  REG AX IS MODIFIED
;  FLAGS ARE MODIFIED
;-----------------------------------------
	MOV	AX,CRC_REG
					;THE FOLLOWING INSTUCTIONS
					;WILL SET THE OVERFLOW FLAG
					;IF CARRY AND MS BIT OF CRC
					;ARE UNEQUAL
	RCR	AX,1
	RCL	AX,1
	CLC				;CLEAR CARRY
	JNO	W32_			;SKIP IF NO OVERFLOW
					;IF DATA BIT XORED WITH
					; CRC REG BIT 15 IS ONE
	XOR	AX,0810H		;THEN XOR CRC REG WITH
					; 0810H
	STC				;SET CARRY
W32_:
	RCL	AX,1			;ROTATE CARRY (DATA BIT)
					; INTO CRC REG
	MOV	CRC_REG,AX		;UPDATE CRC_REG
	RET				;FINISHED
CRC_GEN_ 	ENDP
;--------------------------------------------
BEGIN_OP_	PROC	NEAR		; START TAPE AND DELAY
;
;--------------------------------------------
	CALL	MOTOR_ON_		;TURN ON MOTOR
	MOV	BL,42H			;DELAY FOR TAPE DRIVE
					;TO GET UP TO SPEED  (1/2 SEC)
W33_:
	MOV	CX,700H 		;INNER LOOP= APPROX. 10 MILLISEC
W34_:	LOOP	W34_
	DEC	BL
	JNZ	W33_
	RET
BEGIN_OP_	ENDP